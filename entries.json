[{"title":"Javscriptのクラス対応(=React 0.13対応)のFlummoxを試してみた","url":"/2015/02/16/react-flummox-demo/","date":"2015-02-16","content":"前回の記事で快適なReact環境を手に入れることが出来た私ですが、Fluxを導入しようとして壁にぶち当たりました。Fluxxorなどの有名なFlux実装などはStoreとComponentの紐付けに従来のMixinを利用することが前提となっていますが、ReactにおいてMixinはReact.Componentを利用していると使えません。ちょっとGithubを見ていたらacdlite/flummoxが特徴にReact 0.13対応だと書いてあったのでとりあえずTodoを実装しました。Todoデモソースコード簡単な説明Actionsclass TodoActions extends Actions  createTodo: (text) -\u0026gt;    id = (+new Date() + Math.floor(Math.random() * 999999)).toString(36)    {      id: id      text: text      complete: false    }関数の返り値が自動的にDispatcherに送られる。(undefinedを送るとDispatcherに無視されるので注意)Storeclass TodoStore extends Store  constructor: (flux) -\u0026gt;    super    todoActions = flux.getActionIds('todo')    @register(todoActions.createTodo, @handleNewTodo)    @state = {      todos: {        1: {          id: 1          complete: true          text: \"hoge\"        }      }    }  handleNewTodo: (todo) =\u0026gt;    todos = @state.todos    todos[todo.id] = todo    @setState todos: todosReact.Componentっぽく書ける。setState()すると自動的にDispatcherにemitされ紐付いたComponentが更新される。@register(actionId, handler)でDispatcherにhandlerが登録される。ActionsIdが示すアクションの返り値がDispatcherを介してhandlerの引数となりhandlerが実行される。handlerは関数だったらなんでもいいらしいが、普通にメソッドを渡すといい。Fluxclass AppFlux extends Flux  constructor: -\u0026gt;    super    @createActions('todo', TodoActions)    @createStore('todo', TodoStore, @)createActions(key, ActionsClass, \u0026hellip;args)とcreateStore(key, StoreClass, \u0026hellip;args)でActionsとStoreが登録できる。argsはそれぞれcreateするときの引数になる(この場合Storeの方はnew TodoStore(this)となる)このインスタンスのメソッドgetActions(key)やgetStore(key)を呼び出すとActionsやStoreのインスタンスが返ってくる。Componentあとはflux = new AppFlux()してComponentを書いていく。React.render(React.createFactory(Application)(flux: flux), document.getElementById('container'))class Application extends React.Component  render: =\u0026gt;    jade.compile(\"\"\"      FluxComponent(flux=flux connectToStores=['todo'])        TodoPanel    \"\"\")(_.assign(@, @props, @state))FluxContainer flux=flux connectToStores=[key]とするとStoreの@stateがFluxComponentの@propsになる。だから、中のComponentから参照できる。(この理解が微妙に適当。親のpropsをなんで参照できるのか分かってないまま書いた)FluxComponentは別に配列じゃなくてもいい。FluxComponent connectToStores={{  posts: store =\u0026gt; ({    post: store.getPost(this.props.post.id),  }),  comments: store =\u0026gt; ({    comments: store.getCommentsForPost(this.props.post.id),  })}}Actionを呼び出すときは@props.flux.getActions(\u0026quot;todo\u0026quot;).createTodo(@state.newTodoText)といった感じ。所感こんな感じにFLux書きたかった。Facebookのfluxは初見の私には魔法の言葉が飛び交っているようにしか見えなかったです。参考flummox/quick-start.md at master · acdlite/flummoxflummox/react-integration.md at master · acdlite/flummox"},{"title":"React.jsをCoffeeScriptとjadeで書く","url":"/2015/02/13/react-jade-coffee/","date":"2015-02-13","content":"はじめにReact v0.13.0 Beta 1 | ReactReact.Componentを使うと生のJSのclass形式でReact Componentを定義できるreactjs - react-jadeでjadeテンプレートから仮想DOMを出力する - QiitaJSXのXの部分をjadeで書けるようにするライブラリ (Jade -\u003e React VDOM)ここあたりの記事を読んでRiot.jsなら素でできるCoffeeScriptとJadeの組み合わせがReactでも出来そうだと気づいたので試行錯誤中、よさ気な書き方を見つけた話です。結論こうです。https://gist.github.com/uzimith/145a0cf8e342dc46ac96React = require('react')jade = require('react-jade')_ = require('lodash')class Counter extends React.Component  constructor: -\u0026gt;    @state =      count: 0  tick: =\u0026gt;    @setState count: @state.count + 1  render: =\u0026gt;    jade.compile(\"\"\"      #counter        span Count :        button(onClick=tick)= count    \"\"\")(_.assign {}, @, @props, @state)React.render(React.createFactory(Counter)(), document.getElementById('container'))React.jsの俺的主なキツさの原因である今どき生HTML, なんかめっちゃ多いthis, React.CreateComponet, getInitialStateとかいう意味不明なメソッド等々がまとめて解決されて良さそうです。コメントQiitaを見ていたら@mizchiさんがreact-jadeを使ってるとのことで下記のプロジェクトを見てたらtemplate(_.extend {}, @, @props, @state)とjadeテンプレートを呼び出していました。thisに定義されている関数とpropsとstateの値をマージしてテンプレートに渡す手法がまさに自分の求めていたものでさすが利用者は違いますね。俺専用ReactのSVGスケッチ環境作った - mizchi\u0026rsquo;s blogreact-jadeにはjade.compileFile()といった関数もあるのでいざとなったらテンプレートのファイル分割も簡単にできるのも利点になりそうです。browserifyで使ってるライブラリjadejs/react-jadejnordberg/coffeeifyまだreact-jadeがreact v0.13 betaに対応していないので依存関係削除してインストールしてますが多分問題無いと思うのでリリースされたら対応されるんじゃないでしょうか。所感React.CreateElementやReact.DOMなどを生で駆使するとかラッパーを書いて頑張るとか考えたんですが他で定義したコンポーネントがタグを書くだけで呼び出せるあたり、この手法が一番良さそうです。"},{"title":"Riot.jsでFluxのデモ実装した。","url":"/2015/02/11/riotjs-de-flux/","date":"2015-02-11","content":"フロントエンド開発でコンポーネント指向で書きたいのは間違いないんですが、Reactは簡単な事をするのにも大量のコードを必要として手軽に書くのには辛いライブラリだと思っていたところ、Qiitaでよさ気なライブラリが話題になってました。Riot.js 2.0 を触ってみた — まだReactで消耗しているの? - QiitaRiotjsのいいところ - Qiitaもともとfluxのデモコードがまったく理解できなくて悩んでいたところだったので2つのデモを実装しました。TodoChathttps://github.com/uzimith/flux-practiceFluxについてfluxのコンセプトについては公式サイト読んでても全く理解できなかったので、下のサイトを見て覚えました。Fluxアーキテクチャの覚え書きを書いた - snyk_s logFluxとはなんだったのか + misc at 2014 - snyk_s logWhat the flux?Actionが(ユーザーの)動作、DispatcherがObserver、StoreがModelでAction -\u003e Dispatcher -\u003e Store -\u003e Viewの一方通行でデータが動くと思えば大体合ってる気がします。しかし、いまだにWEB APIがActionCreaterから呼び出される利点が未だに分かってないです。Storeで隠蔽してもいいと思うんですが。複数のStoreを叩く必要があるAPI呼び出しを書く際に困らない、のかなといったところ。"},{"title":"jspmって遅い？","url":"/2015/02/02/jspm-is-slow/","date":"2015-02-02","content":"jspmについてみなさんjspmってご存知ですか。自分はQiitaの記事で知ったんですけど。jspm で快適 javascript 生活（クライアントサイド JS の依存管理決定版） - QiitaES6 module loaderを利用してES6のimport文で前もってダウンロードしていたパッケージを読み込む仕組みになってるみたいです。依存も解決してくれるし特にnpmでもgithubでもbowerでもインストールできるのが明らかな優位な点っぽいです。importって速度的に大丈夫なの？jspm initってやるとconfig.jsとes6-module-loader.jsとかが入ったjspm_packagesのフォルダが生成されるんですが、そんないろんなファイルをインポートして遅くならないかなって思いjspm slowとかでぐぐてみたんですけど特に計測してるサイトとか無かったのでまあ問題ないものかなとReactを書き始めてみました。すると表示が明らかに待たされて違和感バリバリだったのでwatchifyでも変換したファイルを読み込む場合とくらべてみました。jspmの場合    https://github.com/uzimith/flux-todo-practice/tree/692aa4eb33afd1fd372d51da10b517db4384d0d71.30 swatchifyの場合    https://github.com/uzimith/flux-todo-practice/tree/4d2bc63b8026cdc42ebb5d2bac99733eecb188b9#275 msさすがに文字を出すだけでこの速度になるようでは実用性に欠けるのではないかと思っていたところProdoction環境用のファイル生成法がありました。jspm bundleしてbuild.jsを作って読み込ませるといいらしい。    324 msと、かなり早くなりました。とはいえwatchifyは250ms前後で安定してるのでこのコードの場合はwatchifyの生成するコードの方が若干速いです。所感jspmでもbundleすれば十分速度が出るっぽいです。実はトップページを目を通せばひと目でわかることなんですが。For production, optimize into a bundle, layered bundles or a self-executing bundle with a single command.とはいえ自分的には開発中レンダリングが遅いほうが苦になるのが目に見えてるし、JSXで書くためにパスの指定が.jsx!になるとださいし、6to5ify,reactify,uglifyなどwatchifyで機能性は十分、むしろ高いとjspmを使う理由は見当たらないといったところです。ビルドのほうが時間がかかるということならjspmのほうがいいと思いますが、大規模なプロジェクトとかだとそうなんですかね？"},{"title":"Oboe.jsのデモ","url":"/2015/01/14/oboe-sample/","date":"2015-01-14","content":"今日はOboe.jsを触っていたのでその記事です。Oboe.jsとはJSONをストリーミングで読み込むライブラリです。通常のAJAXだとJSONをすべて読み込むまで待機するため大きいファイルを扱ったり、モバイル環境のような低速環境だったりすると読み込み完了までなんの情報も得られないという欠点を改善してくれます。とはいえ、いまいちピンとこないのでデモサイト作って動作確認してました。コード例とりあえずExampleを見る。Oboe.jsの目的ではないが、AJAXライブラリとしても使える。oboe('/myapp/things.json')   .done(function(things) {      // すべて読み込みが完了した場合   })   .fail(function() {      // なんらかのエラーが発生した場合   });ストリーミングで受け取るには以下こういうJSONが来るとして{   \"foods\": [      {\"name\":\"aubergine\",    \"colour\":\"purple\"},      {\"name\":\"apple\",        \"colour\":\"red\"},      {\"name\":\"nuts\",         \"colour\":\"brown\"}   ],   \"badThings\": [      {\"name\":\"poison\",       \"colour\":\"pink\"},      {\"name\":\"broken_glass\", \"colour\":\"green\"}   ]}oboe.node(\u0026lsquo;pattern\u0026rsquo;, callback)を指定する。oboe('/myapp/things.json')   .node('foods.*', function( foodThing ){      // 'foods.*'に該当する新しい要素を見つけるとこのコールバックが呼ばれる。      console.log( 'Go eat some', foodThing.name);   })   .node('badThings.*', function( badThing ){      console.log( 'Stay away from', badThing.name);   })   .done(function(things){      console.log(         'there are', things.foods.length, 'things to eat',         'and', things.nonFoods.length, 'to avoid');    });oboe.path(\u0026lsquo;pattern\u0026rsquo;, callback)を利用することでoboe.node()よりも早くcallbackを呼び出すことができる。var currentPersonElement;oboe('people.json')   .path('people.*', function(){      // パターンに該当する要素が存在することが分かったら      // 中身を読み込む前にpathで指定されたコールバックを呼び出す。      // 例えば、ここでは人物が読み込まれると分かった時点で      // div要素を作ることで、とりあえず人物が読み込まれることをユーザーに示すことができる。      currentPersonElement = $('\u0026lt;div class=\"person\"\u0026gt;');      $('#people').append(currentPersonElement);   })   .node({      'people.*.name': function( name ){         // 名前を見つけた時点でdiv要素に名前を埋め込む         currentPersonElement.append(            '\u0026lt;span class=\"name\"\u0026gt;' + name + '\u0026lt;/span\u0026gt;');      },      'people.*.email': function( email ){         // メールアドレスを見つけた時点でdiv要素に名前を埋め込む         currentPersonElement.append(            '\u0026lt;span class=\"email\"\u0026gt;' + email + '\u0026lt;/span\u0026gt;');      }   });パターンの例がこちら*が任意のオブジェクト、!がルートと言った感じ。使ってみた{    \"article\": [        {            \"text\": \"...\"        }        // ... (10000件)    ]}みたいなJSONを作って読み込ませてみました。oboe.done()すべて読み込んでから表示します。$ = require(\"jquery\");oboe = require(\"oboe\");dom = $(\"#articles\");dom.append(\"\u0026lt;div\u0026gt;start\u0026lt;/div\u0026gt;\");oboe(\"articles.json\").done(function(data) {  data.article.map(function(article) {    dom.prepend(\"\u0026lt;div\u0026gt;\"+article.text+\"\u0026lt;/div\u0026gt;\");  })})oboe.done()oboe.node()ストリーミングで表示します。$ = require(\"jquery\");oboe = require(\"oboe\");dom = $(\"#articles\");dom.append(\"\u0026lt;div\u0026gt;start\u0026lt;/div\u0026gt;\");oboe(\"articles.json\").node('article.*', function(article) {  dom.prepend(\"\u0026lt;div\u0026gt;\"+article.text+\"\u0026lt;/div\u0026gt;\");});oboe.node()所感ローカルで試す分には回線が早すぎて関数呼び出しの分か、むしろnode()の方がレンダリングが遅かったんですが、回線速度を下げてみると確かに順次表示されてました。大きいJSONを読み込む際にはいいかもしれません。"},{"title":"middleman-blogでの検索機能をJavascript(React)で実装した。","url":"/2015/01/11/middleman-blog-search/","date":"2015-01-11","content":"middleman-blogの検索機能の前例はあるんですがjQueryを利用しているため宗教上の理由により使用できません。説明最近はReactが気になっているのでこちらで実装しました。こちらがデモです。前例に比べて該当部分を表示する機能も追加したので使いやすいんじゃないかと。実装ソースコードはこちらです。uzimith/middleman-blog-search-sample参考にどうぞ。所感Reactのチュートリアル見ながら書いてたら簡単に書けました。さらにちょうど先月のAdvent Calendarが分かりやすいので、いま始めやすいと思います。一人React.js Advent Calendar 2014 - Qiita書き始めは双方向バインドじゃないのかと若干失望気味だったんですが、データの流れを一方向にすることでアプリケーションを複雑さを減らすという思想が結構良いですね。一度Fluxを使った中規模アプリケーション書いてみたいです。Reactはコンポーネント思想でつまりいろいろ飛び飛びで見なくても、その機能のすべてが集まってる、そういう感じで書く印象です。Web ComponentsとPolymerが同じ思想で出来てるのかなといった感じですが、Polymerは将来的に正しく未来のWebはこう書ければいいという夢を語る実装で、Reactは現実的に実用できる範囲で実装されているんでしょう。いまPolymerを使うと遅すぎて話にならないですが、Web ComponentsはC++で実装されるわけですからそのうち早くなる未来が待ってるはず。それまではコンポーネント思想ならReactですね。よさ気なライブラリです。"},{"title":"middlemanでReactを書く","url":"/2015/01/06/middleman-react/","date":"2015-01-06","content":"JavascriptのライブラリといえばAngularJSとかvue.jsなどが流行っていますが今回はさらなる流行の最先端Reactです。というわけで書き始めようと思うのですが、書き方がいろいろあって一番簡単なのはCDNを使うことです。\u0026lt;script src=\"http://fb.me/react-0.11.1.js\"\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\"http://fb.me/JSXTransformer-0.11.1.js\"\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script type=\"text/jsx;harmony=true\"\u0026gt;//ここに書ける\u0026lt;/script\u0026gt;さすがにコレはリアルタイムでコンパイルしているので遅くなるみたいです。普通こういったJavascriptライブラリを書くとなるとGulpを使うことになりますがちょっと気持ちが萎える(Gulp好きじゃない)わりにいい感じにMiddlemanと協調するGulpfileを書けなかった(だからキライ)のでもうmiddlemanに処理させたいと思います。というかいまMiddlemanで書いてるんだから、よしなに頑張ってくれ。というわけでmiddleman-reactです。公式のreactjs/react-railsにインスパイアされた(ていうかパクった)middleman拡張です。Gemfilegem \"middleman-react\"config.rbactivate :react, harmony: trueafter_configuration do  sprockets.append_path File.dirname(::React::Source.bundled_path_for('react.js'))endsource/javascripts/all.js//= require react-with-addons//= require_tree .あとはjavascripts配下に.js.jsxファイルを追加していくといい感じに書けます。簡単ですね。HTMLのbodyの最後とかで下みたく書いたりとかすればいいんじゃないかと。hoge.slim#hogehoge= javascript_include_tag \"all\"ところでmiddleman-reactのharmonyオプションですが、もともと見当たらなかったので私が追加しました。ES6やES7の構文がコンパイルできるようになります。つまり下記が使えるようになります。実はあまり調べてませんが。es6-arrow-functionses6-object-concise-methodes6-object-short-notationes6-classeses6-rest-paramses6-templateses6-destructuringes7-spread-propertyhttps://github.com/facebook/react/blob/master/vendor/fbtransform/visitors.jsアロー関数やテンプレートリテラルは便利なのでぜひお使いください。所感簡単に導入できるのはいいんですがやっぱりrequireが使いたくなってきますね。superagentなんかはrequireできないと使えないです。ここあたりのJavascriptライブラリのベストプラクティスが分からなくていつも困ってます。今思っているのはGuardからwatchifyを呼び出すのが汎用的な解決なんじゃないかなってことです。試してないですが。"},{"title":"middlemanでファイルを書き換えてもサーバーに反映されない。","url":"/2015/01/04/middleman-bug/","date":"2015-01-04","content":"OS X Yosemite 10.10.1ruby 2.1.2p95 (2014-05-08 revision 45877) [x86_64-darwin14.0]middleman (3.3.7)middlemanいじってもconfig.rbやhelperメソッド書き換えても反映されなくて違和感を覚えていたらOSXのバグらしき報告がありました。Middleman 3.0 requires manual server restart for any change in config.rb or middleman-blog · Issue #595 · middleman/middlemanなるほどと思って、再起動したらLiveReloadが動かなくなりました。なるほど。確かにサーバーの再起動してるよりは手動で更新する方がはるかにマシなんですが。追記(15/01/06)やっぱり不安定で現象が再現しないですね。サーバー再起動せずに設定が反映されない/LiveReloadが動かないといった感じなんですが時たま反応していて困ります。結局上のページ曰く「原因はOS X FSEvents bugなんじゃないか」「サーバーの問題なのでは、Powで動かしたい」「Powはv4で対応予定」とかなんとか。v4が今alpha6なので待っているといいかもしれません。"},{"title":"ブログはじめる","url":"/2015/01/04/start/","date":"2015-01-04","content":"ブログです。基本的には個人情報を発信することに意義はないと思っているんですが、自身のコンテンツ力を上げていく必要性もヒシヒシ感じる日々なので、年も明けて始めるのにもちょうどいいんじゃないかと。middleman-blogとかいうスゴいソフトウェアのお陰でvimさえあれば更新出来ちゃうので、自分みたいなものぐさな人でも軽く更新出来る予定です。これでGithubのContributionsもガンガン増えちゃうね。"}]
